targetEventsFA_stage1 <- targetEvents1[2]
wei_IA <- sqrt(targetEventsIA_stage1/targetEventsIA_all)
wei_FA <- sqrt(targetEventsFA_stage1/targetEventsFA_all)
bound_z_IA <- d$criticalValues[1]
bound_z_FA <- d$criticalValues[2]
rho <- 0.7
hr_trt <- c(1,1,1)
orr_trt <- c(0.2, .2, .2)
hazards <- c(log(2)/medianOS_c, log(2)/medianOS_c*hr_trt)
orrs <- c(0.2, orr_trt)
test.method <- "dunnett"
results <- getOC_ph23_par(ncore = nclust, seed = 453453, nsim = 10000,
test.method = test.method, approach = "disjoint",
n1 = rep(n1_per_arm, num_trt+1), n2 = rep(n2_per_arm, 2),
duration1 = accrualTime_stage1, duration2 = accrualTime_stage2,
enrollment_hold = enrollment_hold, hazard = hazards, orr = orrs,
rho = rho, dropout = rep(1e-10, 4), a1 = 1, a2 = 1,
min_followup = 4, targetEventsIA_all = targetEventsIA_all,
targetEventsFA_all = targetEventsFA_all, w = c(0.7, 0.73),
bound_z = c(bound_z_IA, bound_z_FA), alpha = alpha, update_bound = FALSE,
dose_selection_endpoint = "ORR")
res.power[[i]] <- results
print(apply(res.power[[i]], 2, mean, na.rm = TRUE))
n1_per_arm <- n1_seq[i]
n2_per_arm <- (ntotal - n1_per_arm*(num_trt+1))/2
n_per_arm <- n1_per_arm + n2_per_arm
accrualTime_stage1 <- ceiling(n1_per_arm*(num_trt+1)/accrual_rate_stage1)
accrualTime_stage2 <- ceiling(n2_per_arm*2/accrual_rate_stage2)
(targetEventsFA_all <- round(n_per_arm*2*maturity))
(targetEventsIA_all <- round(targetEventsFA_all*IF))
assHR_for_weights <- 0.67 # assumed HR for getting expected number of events from stage 1
d <- getDesignGroupSequential(
kMax = 2,
alpha = alpha,
sided = 1,
informationRates = c(targetEventsIA_all/targetEventsFA_all, 1),
typeOfDesign = "asOF"
)
d_power <- getPowerSurvival(
design = d,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = c(0, accrualTime_stage1, accrualTime_stage1 + enrollment_hold,
accrualTime_stage1+ enrollment_hold + accrualTime_stage2),
accrualIntensity = c(n1_per_arm*2/accrualTime_stage1, 0, n2_per_arm*2/accrualTime_stage2),
maxNumberOfEvents = targetEventsFA_all,
directionUpper = FALSE
)
times <- d_power$analysisTime
maxN <- n1_per_arm*2
probEvent <- getEventProbabilities(time = times,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = 0, accrualIntensity = n1_per_arm*2/accrualTime_stage1,
maxNumberOfSubjects = maxN)
(targetEvents1 <- round(probEvent$overallEventProbabilities*maxN))
targetEventsIA_stage1 <- targetEvents1[1]
targetEventsFA_stage1 <- targetEvents1[2]
wei_IA <- sqrt(targetEventsIA_stage1/targetEventsIA_all)
wei_FA <- sqrt(targetEventsFA_stage1/targetEventsFA_all)
bound_z_IA <- d$criticalValues[1]
bound_z_FA <- d$criticalValues[2]
rho <- 1
hr_trt <- c(1,1,1)
orr_trt <- c(0.2, .2, .2)
hazards <- c(log(2)/medianOS_c, log(2)/medianOS_c*hr_trt)
orrs <- c(0.2, orr_trt)
test.method <- "dunnett"
results <- getOC_ph23_par(ncore = nclust, seed = 453453, nsim = 10000,
test.method = test.method, approach = "disjoint",
n1 = rep(n1_per_arm, num_trt+1), n2 = rep(n2_per_arm, 2),
duration1 = accrualTime_stage1, duration2 = accrualTime_stage2,
enrollment_hold = enrollment_hold, hazard = hazards, orr = orrs,
rho = rho, dropout = rep(1e-10, 4), a1 = 1, a2 = 1,
min_followup = 4, targetEventsIA_all = targetEventsIA_all,
targetEventsFA_all = targetEventsFA_all, w = c(0.7, 0.73),
bound_z = c(bound_z_IA, bound_z_FA), alpha = alpha, update_bound = FALSE,
dose_selection_endpoint = "ORR")
res.power[[i]] <- results
print(apply(res.power[[i]], 2, mean, na.rm = TRUE))
i
rm(list = ls())
i=4
library(Phase23Dose)
knitr::opts_chunk$set(echo = TRUE, cache = FALSE)
nclust = 10
nsim_per_cluster <- 1000 # set at least 1000 for final report
## Function input
seed <- 2025
update_bound_FA <- TRUE
alpha <- 0.025
medianOS_c <- 10
accrual_rate_stage1 = 25
accrual_rate_stage2 = 25
enrollment_hold <- 5
maturity <- 0.7
IF <- 0.7
num_trt <- 3
ntotal <- 550
n1_seq <- seq(60, 100, 5)
Nseq <- length(n1_seq)
gpower <- cpower <- csps <- rep(NA, Nseq)
studyDuration <- IAtime <- FAtime <- rep(NA, Nseq)
## Start finding the stage 1 sample size
res.power <- list()
i=4
n1_per_arm <- n1_seq[i]
n2_per_arm <- (ntotal - n1_per_arm*(num_trt+1))/2
n_per_arm <- n1_per_arm + n2_per_arm
accrualTime_stage1 <- ceiling(n1_per_arm*(num_trt+1)/accrual_rate_stage1)
accrualTime_stage2 <- ceiling(n2_per_arm*2/accrual_rate_stage2)
(targetEventsFA_all <- round(n_per_arm*2*maturity))
(targetEventsIA_all <- round(targetEventsFA_all*IF))
assHR_for_weights <- 0.67 # assumed HR for getting expected number of events from stage 1
d <- getDesignGroupSequential(
kMax = 2,
alpha = alpha,
sided = 1,
informationRates = c(targetEventsIA_all/targetEventsFA_all, 1),
typeOfDesign = "asOF"
)
d_power <- getPowerSurvival(
design = d,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = c(0, accrualTime_stage1, accrualTime_stage1 + enrollment_hold,
accrualTime_stage1+ enrollment_hold + accrualTime_stage2),
accrualIntensity = c(n1_per_arm*2/accrualTime_stage1, 0, n2_per_arm*2/accrualTime_stage2),
maxNumberOfEvents = targetEventsFA_all,
directionUpper = FALSE
)
times <- d_power$analysisTime
maxN <- n1_per_arm*2
probEvent <- getEventProbabilities(time = times,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = 0, accrualIntensity = n1_per_arm*2/accrualTime_stage1,
maxNumberOfSubjects = maxN)
(targetEvents1 <- round(probEvent$overallEventProbabilities*maxN))
targetEventsIA_stage1 <- targetEvents1[1]
targetEventsFA_stage1 <- targetEvents1[2]
wei_IA <- sqrt(targetEventsIA_stage1/targetEventsIA_all)
wei_FA <- sqrt(targetEventsFA_stage1/targetEventsFA_all)
bound_z_IA <- d$criticalValues[1]
bound_z_FA <- d$criticalValues[2]
rho <- 1
hr_trt <- c(1,1,1)
orr_trt <- c(0.2, .2, .2)
hazards <- c(log(2)/medianOS_c, log(2)/medianOS_c*hr_trt)
orrs <- c(0.2, orr_trt)
test.method <- "dunnett"
results <- getOC_ph23_par(ncore = nclust, seed = 453453, nsim = 10000,
test.method = test.method, approach = "disjoint",
n1 = rep(n1_per_arm, num_trt+1), n2 = rep(n2_per_arm, 2),
duration1 = accrualTime_stage1, duration2 = accrualTime_stage2,
enrollment_hold = enrollment_hold, hazard = hazards, orr = orrs,
rho = rho, dropout = rep(1e-10, 4), a1 = 1, a2 = 1,
min_followup = 4, targetEventsIA_all = targetEventsIA_all,
targetEventsFA_all = targetEventsFA_all, w = c(0.7, 0.73),
bound_z = c(bound_z_IA, bound_z_FA), alpha = alpha, update_bound = FALSE,
dose_selection_endpoint = "ORR")
res.power[[i]] <- results
print(apply(res.power[[i]], 2, mean, na.rm = TRUE))
n1_per_arm <- n1_seq[i]
n2_per_arm <- (ntotal - n1_per_arm*(num_trt+1))/2
n_per_arm <- n1_per_arm + n2_per_arm
accrualTime_stage1 <- ceiling(n1_per_arm*(num_trt+1)/accrual_rate_stage1)
accrualTime_stage2 <- ceiling(n2_per_arm*2/accrual_rate_stage2)
(targetEventsFA_all <- round(n_per_arm*2*maturity))
(targetEventsIA_all <- round(targetEventsFA_all*IF))
assHR_for_weights <- 0.67 # assumed HR for getting expected number of events from stage 1
d <- getDesignGroupSequential(
kMax = 2,
alpha = alpha,
sided = 1,
informationRates = c(targetEventsIA_all/targetEventsFA_all, 1),
typeOfDesign = "asOF"
)
d_power <- getPowerSurvival(
design = d,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = c(0, accrualTime_stage1, accrualTime_stage1 + enrollment_hold,
accrualTime_stage1+ enrollment_hold + accrualTime_stage2),
accrualIntensity = c(n1_per_arm*2/accrualTime_stage1, 0, n2_per_arm*2/accrualTime_stage2),
maxNumberOfEvents = targetEventsFA_all,
directionUpper = FALSE
)
times <- d_power$analysisTime
maxN <- n1_per_arm*2
probEvent <- getEventProbabilities(time = times,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = 0, accrualIntensity = n1_per_arm*2/accrualTime_stage1,
maxNumberOfSubjects = maxN)
(targetEvents1 <- round(probEvent$overallEventProbabilities*maxN))
targetEventsIA_stage1 <- targetEvents1[1]
targetEventsFA_stage1 <- targetEvents1[2]
wei_IA <- sqrt(targetEventsIA_stage1/targetEventsIA_all)
wei_FA <- sqrt(targetEventsFA_stage1/targetEventsFA_all)
bound_z_IA <- d$criticalValues[1]
bound_z_FA <- d$criticalValues[2]
rho <- 1
hr_trt <- c(1,1,1)
orr_trt <- c(0.2, .2, .2)
hazards <- c(log(2)/medianOS_c, log(2)/medianOS_c*hr_trt)
orrs <- c(0.2, orr_trt)
test.method <- "dunnett"
results <- getOC_ph23_par(ncore = nclust, seed = 453453, nsim = 1000,
test.method = test.method, approach = "disjoint",
n1 = rep(n1_per_arm, num_trt+1), n2 = rep(n2_per_arm, 2),
duration1 = accrualTime_stage1, duration2 = accrualTime_stage2,
enrollment_hold = enrollment_hold, hazard = hazards, orr = orrs,
rho = rho, dropout = rep(1e-10, 4), a1 = 1, a2 = 1,
min_followup = 4, targetEventsIA_all = targetEventsIA_all,
targetEventsFA_all = targetEventsFA_all, w = c(0.7, 0.73),
bound_z = c(bound_z_IA, bound_z_FA), alpha = alpha, update_bound = FALSE,
dose_selection_endpoint = "ORR")
res.power[[i]] <- results
print(apply(res.power[[i]], 2, mean, na.rm = TRUE))
bound_z_FA
View(results)
n1_per_arm <- n1_seq[i]
n2_per_arm <- (ntotal - n1_per_arm*(num_trt+1))/2
n_per_arm <- n1_per_arm + n2_per_arm
accrualTime_stage1 <- ceiling(n1_per_arm*(num_trt+1)/accrual_rate_stage1)
accrualTime_stage2 <- ceiling(n2_per_arm*2/accrual_rate_stage2)
(targetEventsFA_all <- round(n_per_arm*2*maturity))
(targetEventsIA_all <- round(targetEventsFA_all*IF))
assHR_for_weights <- 0.67 # assumed HR for getting expected number of events from stage 1
d <- getDesignGroupSequential(
kMax = 2,
alpha = alpha,
sided = 1,
informationRates = c(targetEventsIA_all/targetEventsFA_all, 1),
typeOfDesign = "asOF"
)
d_power <- getPowerSurvival(
design = d,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = c(0, accrualTime_stage1, accrualTime_stage1 + enrollment_hold,
accrualTime_stage1+ enrollment_hold + accrualTime_stage2),
accrualIntensity = c(n1_per_arm*2/accrualTime_stage1, 0, n2_per_arm*2/accrualTime_stage2),
maxNumberOfEvents = targetEventsFA_all,
directionUpper = FALSE
)
times <- d_power$analysisTime
maxN <- n1_per_arm*2
probEvent <- getEventProbabilities(time = times,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = 0, accrualIntensity = n1_per_arm*2/accrualTime_stage1,
maxNumberOfSubjects = maxN)
(targetEvents1 <- round(probEvent$overallEventProbabilities*maxN))
targetEventsIA_stage1 <- targetEvents1[1]
targetEventsFA_stage1 <- targetEvents1[2]
wei_IA <- sqrt(targetEventsIA_stage1/targetEventsIA_all)
wei_FA <- sqrt(targetEventsFA_stage1/targetEventsFA_all)
bound_z_IA <- d$criticalValues[1]
bound_z_FA <- d$criticalValues[2]
rho <- 1
hr_trt <- c(1,1,1)
orr_trt <- c(0.2, .2, .2)
hazards <- c(log(2)/medianOS_c, log(2)/medianOS_c*hr_trt)
orrs <- c(0.2, orr_trt)
test.method <- "dunnett"
results <- getOC_ph23_par(ncore = nclust, seed = 453453, nsim = 1000,
test.method = test.method, approach = "disjoint",
n1 = rep(n1_per_arm, num_trt+1), n2 = rep(n2_per_arm, 2),
duration1 = accrualTime_stage1, duration2 = accrualTime_stage2,
enrollment_hold = enrollment_hold, hazard = hazards, orr = orrs,
rho = rho, dropout = rep(1e-10, 4), a1 = 1, a2 = 1,
min_followup = 4, targetEventsIA_all = targetEventsIA_all,
targetEventsFA_all = targetEventsFA_all, w = c(0.7, 0.73),
bound_z = c(bound_z_IA, bound_z_FA), alpha = alpha, update_bound = TRUE,
dose_selection_endpoint = "ORR")
res.power[[i]] <- results
print(apply(res.power[[i]], 2, mean, na.rm = TRUE))
## Start simulation
detectCores()
rm(list=ls())
library(knitr)
library(gsDesign)
library(dplyr)
library(rpact)
library(ggplot2)
rm(list=ls())
library(knitr)
library(gsDesign)
library(dplyr)
library(rpact)
library(ggplot2)
library(ggh4x)
library(ggpubr)
library(scales)
library(parallel)
library(doParallel)
library(Phase23Dose)
## Start simulation
detectCores()
nclust = 10
nsim_per_cluster <- 10 # set at least 1000 for final report
## Function input
seed <- 2025
update_bound_FA <- TRUE
alpha <- 0.025
medianOS_c <- 10
accrual_rate_stage1 = 25
accrual_rate_stage2 = 25
enrollment_hold <- 5
maturity <- 0.7
IF <- 0.7
num_trt <- 3
ntotal <- 550
n1_seq <- seq(60, 100, 5)
Nseq <- length(n1_seq)
gpower <- cpower <- csps <- rep(NA, Nseq)
studyDuration <- IAtime <- FAtime <- rep(NA, Nseq)
## Start finding the stage 1 sample size
res.power <- list()
for(i in 1:Nseq){
n1_per_arm <- n1_seq[i]
n2_per_arm <- (ntotal - n1_per_arm*(num_trt+1))/2
n_per_arm <- n1_per_arm + n2_per_arm
accrualTime_stage1 <- ceiling(n1_per_arm*(num_trt+1)/accrual_rate_stage1)
accrualTime_stage2 <- ceiling(n2_per_arm*2/accrual_rate_stage2)
(targetEventsFA_all <- round(n_per_arm*2*maturity))
(targetEventsIA_all <- round(targetEventsFA_all*IF))
assHR_for_weights <- 0.67 # assumed HR for getting expected number of events from stage 1
d <- getDesignGroupSequential(
kMax = 2,
alpha = alpha,
sided = 1,
informationRates = c(targetEventsIA_all/targetEventsFA_all, 1),
typeOfDesign = "asOF"
)
d_power <- getPowerSurvival(
design = d,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = c(0, accrualTime_stage1, accrualTime_stage1 + enrollment_hold,
accrualTime_stage1+ enrollment_hold + accrualTime_stage2),
accrualIntensity = c(n1_per_arm*2/accrualTime_stage1, 0, n2_per_arm*2/accrualTime_stage2),
maxNumberOfEvents = targetEventsFA_all,
directionUpper = FALSE
)
times <- d_power$analysisTime
maxN <- n1_per_arm*2
probEvent <- getEventProbabilities(time = times,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = 0, accrualIntensity = n1_per_arm*2/accrualTime_stage1,
maxNumberOfSubjects = maxN)
(targetEvents1 <- round(probEvent$overallEventProbabilities*maxN))
targetEventsIA_stage1 <- targetEvents1[1]
targetEventsFA_stage1 <- targetEvents1[2]
wei_IA <- sqrt(targetEventsIA_stage1/targetEventsIA_all)
wei_FA <- sqrt(targetEventsFA_stage1/targetEventsFA_all)
bound_z_IA <- d$criticalValues[1]
bound_z_FA <- d$criticalValues[2]
rho <- 0.7
hr_trt <- c(0.85, 0.75, 0.67)
orr_trt <- c(0.25, 0.30, 0.40)
hazards <- c(log(2)/medianOS_c, log(2)/medianOS_c*hr_trt)
orrs <- c(0.2, orr_trt)
test.method <- "dunnett"
results <- getOC_ph23_par(ncore = nclust, seed = seed, nsim = nsim_per_cluster,
test.method = test.method, approach = "disjoint",
n1 = rep(n1_per_arm, num_trt+1), n2 = rep(n2_per_arm, 2),
duration1 = accrualTime_stage1, duration2 = accrualTime_stage2,
enrollment_hold = enrollment_hold, hazard = hazards, orr = orrs,
rho = rho, dropout = rep(1e-10, 4), a1 = 1, a2 = 1,
min_followup = 4, targetEventsIA_all = targetEventsIA_all,
targetEventsFA_all = targetEventsFA_all, w = c(wei_IA, wei_FA),
bound_z = c(bound_z_IA, bound_z_FA), alpha = alpha, update_bound = update_bound_FA,
dose_selection_endpoint = "ORR")
res.power[[i]] <- results
print(apply(res.power[[i]], 2, mean, na.rm = TRUE))
}
save.image("stage1_size.RData")
## results
for(i in 1:Nseq){
doses <- c(3)
sim.results <- res.power[[i]]
csps[i] <- mean(sim.results[,1]%in%doses)
cpower[i] <- mean(sim.results[sim.results[,1]%in%doses, 4])
gpower[i] <- sum(sim.results[sim.results[,1]%in%doses, 4])/nrow(sim.results)
IAtime[i] <- mean(sim.results[,2])
FAtime[i] <- mean(sim.results[,5], na.rm = TRUE)
studyDuration[i] <- mean(sim.results[,6])
}
(res.ph23 <- cbind(n1_seq, csps, cpower, gpower, IAtime, FAtime, studyDuration))
write.csv(res.ph23, "stage1_size.csv")
save.image("stage1_size.RData")
nclust = 10
nsim_per_cluster <- 1000 # set at least 1000 for final report
## Function input
seed <- 2025
update_bound_FA <- TRUE
alpha <- 0.025
medianOS_c <- 10
accrual_rate_stage1 = 25
accrual_rate_stage2 = 25
enrollment_hold <- 5
maturity <- 0.7
IF <- 0.5
num_trt <- 3
ntotal <- 550
n1_seq <- seq(40, 100, 5)
Nseq <- length(n1_seq)
gpower <- cpower <- csps <- rep(NA, Nseq)
studyDuration <- IAtime <- FAtime <- rep(NA, Nseq)
## Start finding the stage 1 sample size
res.power <- list()
i=3
n1_per_arm <- n1_seq[i]
n2_per_arm <- (ntotal - n1_per_arm*(num_trt+1))/2
n_per_arm <- n1_per_arm + n2_per_arm
accrualTime_stage1 <- ceiling(n1_per_arm*(num_trt+1)/accrual_rate_stage1)
accrualTime_stage2 <- ceiling(n2_per_arm*2/accrual_rate_stage2)
(targetEventsFA_all <- round(n_per_arm*2*maturity))
(targetEventsIA_all <- round(targetEventsFA_all*IF))
assHR_for_weights <- 0.67 # assumed HR for getting expected number of events from stage 1
d <- getDesignGroupSequential(
kMax = 2,
alpha = alpha,
sided = 1,
informationRates = c(targetEventsIA_all/targetEventsFA_all, 1),
typeOfDesign = "asOF"
)
d_power <- getPowerSurvival(
design = d,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = c(0, accrualTime_stage1, accrualTime_stage1 + enrollment_hold,
accrualTime_stage1+ enrollment_hold + accrualTime_stage2),
accrualIntensity = c(n1_per_arm*2/accrualTime_stage1, 0, n2_per_arm*2/accrualTime_stage2),
maxNumberOfEvents = targetEventsFA_all,
directionUpper = FALSE
)
times <- d_power$analysisTime
maxN <- n1_per_arm*2
probEvent <- getEventProbabilities(time = times,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = 0, accrualIntensity = n1_per_arm*2/accrualTime_stage1,
maxNumberOfSubjects = maxN)
(targetEvents1 <- round(probEvent$overallEventProbabilities*maxN))
targetEventsIA_stage1 <- targetEvents1[1]
targetEventsFA_stage1 <- targetEvents1[2]
wei_IA <- sqrt(targetEventsIA_stage1/targetEventsIA_all)
wei_FA <- sqrt(targetEventsFA_stage1/targetEventsFA_all)
bound_z_IA <- d$criticalValues[1]
bound_z_FA <- d$criticalValues[2]
rho <- 0.7
hr_trt <- c(0.85, 0.75, 0.67)
orr_trt <- c(0.25, 0.30, 0.40)
hazards <- c(log(2)/medianOS_c, log(2)/medianOS_c*hr_trt)
orrs <- c(0.2, orr_trt)
test.method <- "dunnett"
Nseq
i=13
n1_per_arm <- n1_seq[i]
n2_per_arm <- (ntotal - n1_per_arm*(num_trt+1))/2
n_per_arm <- n1_per_arm + n2_per_arm
accrualTime_stage1 <- ceiling(n1_per_arm*(num_trt+1)/accrual_rate_stage1)
accrualTime_stage2 <- ceiling(n2_per_arm*2/accrual_rate_stage2)
(targetEventsFA_all <- round(n_per_arm*2*maturity))
(targetEventsIA_all <- round(targetEventsFA_all*IF))
assHR_for_weights <- 0.67 # assumed HR for getting expected number of events from stage 1
d <- getDesignGroupSequential(
kMax = 2,
alpha = alpha,
sided = 1,
informationRates = c(targetEventsIA_all/targetEventsFA_all, 1),
typeOfDesign = "asOF"
)
d_power <- getPowerSurvival(
design = d,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = c(0, accrualTime_stage1, accrualTime_stage1 + enrollment_hold,
accrualTime_stage1+ enrollment_hold + accrualTime_stage2),
accrualIntensity = c(n1_per_arm*2/accrualTime_stage1, 0, n2_per_arm*2/accrualTime_stage2),
maxNumberOfEvents = targetEventsFA_all,
directionUpper = FALSE
)
times <- d_power$analysisTime
maxN <- n1_per_arm*2
probEvent <- getEventProbabilities(time = times,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = 0, accrualIntensity = n1_per_arm*2/accrualTime_stage1,
maxNumberOfSubjects = maxN)
(targetEvents1 <- round(probEvent$overallEventProbabilities*maxN))
targetEventsIA_stage1 <- targetEvents1[1]
targetEventsFA_stage1 <- targetEvents1[2]
wei_IA <- sqrt(targetEventsIA_stage1/targetEventsIA_all)
wei_FA <- sqrt(targetEventsFA_stage1/targetEventsFA_all)
bound_z_IA <- d$criticalValues[1]
bound_z_FA <- d$criticalValues[2]
rho <- 0.7
hr_trt <- c(0.85, 0.75, 0.67)
orr_trt <- c(0.25, 0.30, 0.40)
hazards <- c(log(2)/medianOS_c, log(2)/medianOS_c*hr_trt)
orrs <- c(0.2, orr_trt)
test.method <- "dunnett"
library(Phase23Dose)
library(Phase23Dose)
d <- sim_ph23(n1 = c(50, 50, 50, 50), n2 = c(150, 150), duration2 = 400)
View(d)
