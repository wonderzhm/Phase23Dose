test.method == "dunnett"
pall <- generatePvals(g=g, w=weights, cr=cr, p=pvalues, adjusted = FALSE)
library(mvtnorm)
pall <- generatePvals(g=g, w=weights, cr=cr, p=pvalues, adjusted = FALSE)
pselected <- pall[!is.na(pall[, selected]),]
padjusted <- apply(pselected, 1, min, na.rm = TRUE)
padjusted <- getPvals.simes(g=g, w=weights, p=pvalues, selected = selected)
# Get p-values for simes' method
getPvals.simes <- function(g, w, p, selected){
n <- length(p)
weis <- generateWeights(g, w)
res <- rep(NA, nrow(weis))
for(i in 1:nrow(weis)){
res[i] <- simes.test(pvalues = p, weights = weis[i, (1:n)+n])
}
return(res[weis[,selected]==1])
}
padjusted <- getPvals.simes(g=g, w=weights, p=pvalues, selected = selected)
d1IAselected <- d1IA %>% filter(trt%in%c(0, selected))
obsEventsIA_1 <- sum(d1IAselected$eventCut)
obsEventsIA_1
# stage 2:
d2IA <- dIA %>% filter(stage==2)
sum(d2IA$eventCut)
res <- nph::logrank.test(time = d2IA$survTimeCut, event = d2IA$eventCut,
group = as.factor(d2IA$trt), alternative = c("greater"),
rho = 0, gamma = 0, event_time_weights = NULL)
qadjusted <- rep(res$test$p, length(padjusted))
qadjusted
weights
wei
weight
library(Phase23Dose)
?getZstat
sqrt(1-0.8^2)
0.8
getZstat <- function(dat, w, selected = 1, targetEvents, test.method = "dunnett"){
num_trt <- length(unique(dat$trt)) - 1
# dose selection
d1 <- dat %>% filter(stage==1)
d2 <- dat %>% filter(trt%in%c(0, selected))
# cut data
dIA <- cut_by_event(d2, targetEvents = targetEvents)
IA_time <- dIA$calendarCutoff[1]
# stage 1:
d1IA <- cut_by_date(d1, cut_time = IA_time)
pvalues <- rep(NA, num_trt)
for(i in 1:num_trt){
d1IAi <- d1IA %>% filter(trt%in%c(0, i))
res <- nph::logrank.test(time = d1IAi$survTimeCut, event = d1IAi$eventCut,
group = as.factor(d1IAi$trt), alternative = c("greater"),
rho = 0, gamma = 0, event_time_weights = NULL)
pvalues[i] <- res$test$p
}
names(pvalues) <- paste("H", 1:num_trt, sep = "")
g <- matrix(1/(num_trt-1), nrow = num_trt, ncol = num_trt)
diag(g) <- 0
rownames(g) <- colnames(g) <- names(pvalues)
weights <- rep(1, num_trt)/num_trt
cr <- matrix(0.5, num_trt, num_trt)
diag(cr) <- 1
if(test.method == "dunnett"){
pall <- generatePvals(g=g, w=weights, cr=cr, p=pvalues, adjusted = FALSE)
pselected <- pall[!is.na(pall[, selected]),]
padjusted <- apply(pselected, 1, min, na.rm = TRUE)
}else{
padjusted <- getPvals.simes(g=g, w=weights, p=pvalues, selected = selected)
}
d1IAselected <- d1IA %>% filter(trt%in%c(0, selected))
obsEventsIA_1 <- sum(d1IAselected$eventCut)
# stage 2:
d2IA <- dIA %>% filter(stage==2)
res <- nph::logrank.test(time = d2IA$survTimeCut, event = d2IA$eventCut,
group = as.factor(d2IA$trt), alternative = c("greater"),
rho = 0, gamma = 0, event_time_weights = NULL)
qadjusted <- rep(res$test$p, length(padjusted))
# p-value combination
z_IA <- min(w[1]*qnorm(1-padjusted)+w[2]*qnorm(1-qadjusted))
# resulted test statistic
return(list(z=z_IA, obsEvents_stage1 = obsEventsIA_1))
}
getZstat(d, w=c(0.8, sqrt(1-0.8^2)), targetEvents = 25, test.method="dunnett")
getZstat(d, w=c(0.8, sqrt(1-0.8^2)), targetEvents = 25, test.method="simes")
getZstat(d, w=c(0.8, sqrt(1-0.8^2)), selected = 2, targetEvents = 25, test.method="dunnett")
getZstat(d, w=c(0.8, sqrt(1-0.8^2)), selected = 2, targetEvents = 25, test.method="simes")
c(0.8, sqrt(1-0.8^2)
)
0.8^2+0.6^2
library(Phase23Dose)
library(Phase23Dose)
?getZstat
wei_IA = c(0.8, 0.6)
if((sum(wei_IA^2)-1)>0.000001) stop("w1^2 + w2^2 should be equal to one!")
sum(wei_IA^2)-1
wei_FA = c(0.8, 0.6)
## check weights
if((abs(sum(wei_IA^2)-1)+abs(sum(wei_FA^2)-1))>0.000001) stop("w1^2 + w2^2 should be equal to one!")
getZstat <- function(dat, w, selected = 1, targetEvents, test.method = "dunnett"){
num_trt <- length(unique(dat$trt)) - 1
# dose selection
d1 <- dat %>% filter(stage==1)
d2 <- dat %>% filter(trt%in%c(0, selected))
# cut data
dIA <- cut_by_event(d2, targetEvents = targetEvents)
IA_time <- dIA$calendarCutoff[1]
# stage 1:
d1IA <- cut_by_date(d1, cut_time = IA_time)
pvalues <- rep(NA, num_trt)
for(i in 1:num_trt){
d1IAi <- d1IA %>% filter(trt%in%c(0, i))
res <- nph::logrank.test(time = d1IAi$survTimeCut, event = d1IAi$eventCut,
group = as.factor(d1IAi$trt), alternative = c("greater"),
rho = 0, gamma = 0, event_time_weights = NULL)
pvalues[i] <- res$test$p
}
names(pvalues) <- paste("H", 1:num_trt, sep = "")
g <- matrix(1/(num_trt-1), nrow = num_trt, ncol = num_trt)
diag(g) <- 0
rownames(g) <- colnames(g) <- names(pvalues)
weights <- rep(1, num_trt)/num_trt
cr <- matrix(0.5, num_trt, num_trt)
diag(cr) <- 1
if(test.method == "dunnett"){
pall <- generatePvals(g=g, w=weights, cr=cr, p=pvalues, adjusted = FALSE)
pselected <- pall[!is.na(pall[, selected]),]
padjusted <- apply(pselected, 1, min, na.rm = TRUE)
}else{
padjusted <- getPvals.simes(g=g, w=weights, p=pvalues, selected = selected)
}
d1IAselected <- d1IA %>% filter(trt%in%c(0, selected))
obsEventsIA_1 <- sum(d1IAselected$eventCut)
# stage 2:
d2IA <- dIA %>% filter(stage==2)
res <- nph::logrank.test(time = d2IA$survTimeCut, event = d2IA$eventCut,
group = as.factor(d2IA$trt), alternative = c("greater"),
rho = 0, gamma = 0, event_time_weights = NULL)
qadjusted <- rep(res$test$p, length(padjusted))
# p-value combination
z_IA <- min(w[1]*qnorm(1-padjusted)+w[2]*qnorm(1-qadjusted))
# sample size
sample_size <- nrow(d1IA) + nrow(d2IA)
# resulted test statistic
return(list(z=z_IA, obsEvents_stage1 = obsEventsIA_1,
cut_time = IA_time, sample_size = sample_size))
}
d <- sim_ph23(n1_per_arm = 20, n2_per_arm = 30)
getZstat(d, w=c(0.8, sqrt(1-0.8^2)), selected = 2, targetEvents = 25, test.method="dunnett")
getZstat(d, w=c(0.8, sqrt(1-0.8^2)), selected = 2, targetEvents = 10, test.method="dunnett")
getZstat(d, w=c(0.8, sqrt(1-0.8^2)), selected = 2, targetEvents = 1, test.method="dunnett")
getZstat(d, w=c(0.8, sqrt(1-0.8^2)), selected = 2, targetEvents = 9, test.method="dunnett")
getZstat(d, w=c(0.8, sqrt(1-0.8^2)), selected = 2, targetEvents = 8, test.method="dunnett")
selected = 1
targetEvents=9
test.method = "dunnett"
num_trt <- length(unique(dat$trt)) - 1
# dose selection
d1 <- dat %>% filter(stage==1)
d2 <- dat %>% filter(trt%in%c(0, selected))
# cut data
dIA <- cut_by_event(d2, targetEvents = targetEvents)
IA_time <- dIA$calendarCutoff[1]
# stage 1:
d1IA <- cut_by_date(d1, cut_time = IA_time)
pvalues <- rep(NA, num_trt)
for(i in 1:num_trt){
d1IAi <- d1IA %>% filter(trt%in%c(0, i))
res <- nph::logrank.test(time = d1IAi$survTimeCut, event = d1IAi$eventCut,
group = as.factor(d1IAi$trt), alternative = c("greater"),
rho = 0, gamma = 0, event_time_weights = NULL)
pvalues[i] <- res$test$p
}
names(pvalues) <- paste("H", 1:num_trt, sep = "")
g <- matrix(1/(num_trt-1), nrow = num_trt, ncol = num_trt)
diag(g) <- 0
rownames(g) <- colnames(g) <- names(pvalues)
weights <- rep(1, num_trt)/num_trt
cr <- matrix(0.5, num_trt, num_trt)
diag(cr) <- 1
if(test.method == "dunnett"){
pall <- generatePvals(g=g, w=weights, cr=cr, p=pvalues, adjusted = FALSE)
pselected <- pall[!is.na(pall[, selected]),]
padjusted <- apply(pselected, 1, min, na.rm = TRUE)
}else{
padjusted <- getPvals.simes(g=g, w=weights, p=pvalues, selected = selected)
}
d1IAselected <- d1IA %>% filter(trt%in%c(0, selected))
obsEventsIA_1 <- sum(d1IAselected$eventCut)
# stage 2:
nrow(d1IA)
# stage 2:
d2IA <- dIA %>% filter(stage==2)
d2IA
?gsDesign
?gsDesign::gsDesign
library(Phase23Dose)
ph23_sim <- function(ith = 1, seed = 2024, nsim = 1000, test.method = "dunnett",
hazardC = 0.1, hazardT = c(0.1, 0.1, 0.1),
orrC = 0.2, orrT = c(0.2, 0.2, 0.2), rho = 0.7,
dropoutC = 0, dropoutT = c(0, 0, 0),
accrual_rate_stage1 = 25, accrual_rate_stage2 = 25,
n1_per_arm = 50, n2_per_arm = 150,
targetEventsIA_all = 240, targetEventsFA_all = 320,
wei_IA = c(0.8, 0.6), wei_FA = c(0.8, 0.6),
bound_z_IA = 2.44, bound_z_FA = 2,
alpha = 0.025, update_bound_FA = TRUE){
## check weights
if((abs(sum(wei_IA^2)-1)+abs(sum(wei_FA^2)-1))>0.000001) stop("w1^2 + w2^2 should be equal to one!")
## Start simulation
set.seed(seed*ith)
results.names <- c("Selected dose", "IA time", "IA rejct", "FA reject", "FA time",
"Study duration", "Total sample size", "observed correlation",
"actual FA boundary")
results <- matrix(NA, nrow=nsim, ncol=length(results.names))
colnames(results) <- results.names
for(sim in 1:nsim){
## Simulate survival times and tumor responses
num_trt <- length(hazardT)
dat <- sim_ph23(hazardC = hazardC, hazardT = hazardT,
orrC = orrC, orrT = orrT, rho = rho,
accrual_rate_stage1 = accrual_rate_stage1,
accrual_rate_stage2 = accrual_rate_stage2,
n1_per_arm = n1_per_arm, n2_per_arm = n2_per_arm,
dropoutC = dropoutC, dropoutT = dropoutT)
## dose selection
d1 <- dat %>% filter(stage==1)
orr_est <- d1 %>% filter(trt!=0) %>%  group_by(trt) %>% summarise(orr = mean(response))
selected <- orr_est$trt[which.max(orr_est$orr)]
## IA
res_IA <- getZstat(dat = dat, w = wei_IA, targetEvents = targetEventsIA_all,
test.method = test.method)
IA_time <- res_IA$cut_time
obsEventsIA_1 <- res_IA$obsEvents_stage1
IA_sample_size <- res_IA$sample_size
z_IA <- res_IA$z
IA_reject <- (z_IA >= bound_z_IA)
## FA
if(IA_reject){
FA_reject <- IA_reject
FA_time <- NA
Study_duration <- IA_time
total_sample_size <-  IA_sample_size
obs_cor <- NA
if(update_bound_FA) bound_z_FA_obs <- NA
}else{
res_FA <- getZstat(dat = dat, w = wei_FA, targetEvents = targetEventsFA_all,
test.method = test.method)
FA_time <- res_FA$cut_time
obsEventsFA_1 <- res_FA$obsEvents_stage1
FA_sample_size <- res_FA$sample_size
z_FA <- res_FA$z
obs_cor <- wei_IA[1]*wei_FA[1]*sqrt(obsEventsIA_1/obsEventsFA_1) +
wei_IA[2]*wei_FA[2]*sqrt((targetEventsIA_all-obsEventsIA_1)/(targetEventsFA_all-obsEventsFA_1))
if(update_bound_FA){
obs_info_fraction <- obs_cor^2
du <- gsDesign(k = 2, test.type = 1, alpha = alpha, sfu = sfLDOF,
n.I = c(targetEventsIA_all, targetEventsIA_all/obs_info_fraction),
maxn.IPlan = targetEventsFA_all)
bound_z_FA_obs <- du$upper$bound[2]
FA_reject <- (z_FA >= bound_z_FA_obs)
}else{
FA_reject <- (z_FA >= bound_z_FA)
}
Study_duration <- FA_time
total_sample_size <-  FA_sample_size
}
## Save results
results[sim, 1] <- selected
results[sim, 2] <- IA_time
results[sim, 3] <- IA_reject
results[sim, 4] <- FA_reject
results[sim, 5] <- FA_time
results[sim, 6] <- Study_duration
results[sim, 7] <- total_sample_size
results[sim, 8] <- obs_cor
if(update_bound_FA){
results[sim, 9] <- bound_z_FA_obs
}else{
results[sim, 9] <- bound_z_FA
}
}
return(results)
}
res <- ph23_sim(nsim=100)
library(gsDesign)
res <- ph23_sim(nsim=100)
apply(res, 1, mean, rm=TRUE)
apply(res, 2, mean, rm=TRUE)
res <- ph23_sim(nsim=100)
apply(res, 2, mean, rm=TRUE)
res <- ph23_sim(seed = 24232, nsim=100)
apply(res, 2, mean, rm=TRUE)
res <- ph23_sim(seed = 24232, nsim=10)
apply(res, 2, mean, rm=TRUE)
library(Phase23Dose)
library(simtrial)
?getMatrices
??getMatrices
library(Phase23Dose)
library(Phase23Dose)
?getMatrices
??getMatrices
library(gMCP)
??generatePvals
install.packages("gMCP")
?gMCP::getMatrices
library(Phase23Dose)
library(survival)
library(gsDesign)
library(simtrial)
library(dplyr)
library(knitr)
library(rpact)
library(nph)
library(mvtnorm)
library(ggplot2)
library(ggh4x)
library(ggpubr)
library(scales)
library(parallel)
library(doParallel)
library(Phase23Dose)
nclust = 10
#nsim_per_cluster <- 1000
cl <- makeCluster(nclust, type = "PSOCK")
registerDoParallel(cl)
## Export Functions to the Cluster
tmp1 <- clusterCall(cl, function() {source("functions.R"); source("gACT-internal.R");
source("generatePvals.R"); source("generateWeights.R")})
tmp1 <- clusterCall(cl, function() {library(survival)
library(gsDesign)
library(simtrial)
library(dplyr)
library(knitr)
library(rpact)
library(nph)
library(mvtnorm);library(Phase23Dose);
library(parallel)
library(doParallel)})
tmp2 <- clusterExport(cl, list("nclust"))
update_bound_FA <- TRUE ## FA boundary will be updated using the observed correlation.
alpha <- 0.025
medianOS_c <- 10
accrual_rate_stage1 = 25
accrual_rate_stage2 = 25
maturity <- 0.7
IF <- 0.7
num_trt <- 3
n1_per_arm <- 75
ntotal <- 550
n2_per_arm <- (ntotal - n1_per_arm*(num_trt+1))/2
n_per_arm <- n1_per_arm + n2_per_arm
accrualTime_stage1 <- n1_per_arm*(num_trt+1)/accrual_rate_stage1
accrualTime_stage2 <- n2_per_arm*2/accrual_rate_stage2
(targetEventsFA_all <- round(n_per_arm*2*maturity))
(targetEventsIA_all <- round(targetEventsFA_all*IF))
assHR_for_weights <- 1 # assumed HR for getting expected number of events from stage 1
d <- getDesignGroupSequential(
kMax = 2,
alpha = alpha,
sided = 1,
informationRates = c(targetEventsIA_all/targetEventsFA_all, 1),
typeOfDesign = "asOF"
)
d_power <- getPowerSurvival(
design = d,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = c(0, accrualTime_stage1, accrualTime_stage1+accrualTime_stage2),
accrualIntensity = c(accrual_rate_stage1/(num_trt+1)*2, accrual_rate_stage2),
maxNumberOfEvents = targetEventsFA_all,
directionUpper = FALSE
)
times <- d_power$analysisTime
maxN <- n1_per_arm*2
probEvent <- getEventProbabilities(time = times,
hazardRatio = assHR_for_weights, lambda2 = log(2) / medianOS_c,
dropoutRate1 = 0, dropoutRate2 = 0, dropoutTime = 24,
accrualTime = 0, accrualIntensity = accrual_rate_stage1/(num_trt+1)*2, maxNumberOfSubjects = maxN)
(targetEvents1 <- round(probEvent$overallEventProbabilities*maxN))
## get weights
wei_IA <- c(sqrt(targetEventsIA_stage1/targetEventsIA_all),
sqrt(1-targetEventsIA_stage1/targetEventsIA_all))
targetEventsIA_stage1 <- targetEvents1[1]
targetEventsFA_stage1 <- targetEvents1[2]
bound_z_IA <- d$criticalValues[1]
bound_z_FA <- d$criticalValues[2]
hr_trt <- c(1, 1, 1) # HR for treatment arms
orr_trt <- c(0.2, 0.2, 0.2) #  ORR for treatment arms
rhos <- c(0, 0.7, 0.999999) #
test.methods <- c("simes", "dunnett")
sqrt(targetEventsIA_all/targetEventsFA_all) # expected correlation
## get weights
wei_IA <- c(sqrt(targetEventsIA_stage1/targetEventsIA_all),
sqrt(1-targetEventsIA_stage1/targetEventsIA_all))
wei_FA <- c(sqrt(targetEventsFA_stage1/targetEventsFA_all),
sqrt(1-targetEventsFA_stage1/targetEventsFA_all))
wei_FA
wei_IA
input <- list(rho = rep(rhos, each = 2),
test.method = rep(test.methods, 3) )
res.type1global <- list()
for(i in 1:length(input$rho)){
rho <- input$rho[i]
test.method <- input$test.method[i]
results <- parLapply(cl, (1:nclust), fun = getOC_ph23, seed = 202407, nsim = nsim_per_cluster, test.method = test.method,
hazardC = log(2)/medianOS_c, hazardT = log(2)/medianOS_c*hr_trt, orrC = 0.2, orrT = orr_trt, rho = rho, accrual_rate_stage1 = accrual_rate_stage1,
accrual_rate_stage2 = accrual_rate_stage2, n1_per_arm = n1_per_arm, n2_per_arm = n2_per_arm,
targetEventsIA_all = targetEventsIA_all, targetEventsFA_all = targetEventsFA_all,
wei_IA = wei_IA, wei_FA = wei_FA,
bound_z_IA = bound_z_IA, bound_z_FA = bound_z_FA, dropoutC = 1e-10,
ddropoutT = rep(1e-10, 3), alpha = alpha, update_bound_FA = update_bound_FA)
res.type1global[[i]] <- do.call(rbind, results)
#print(apply(res.type1global[[i]], 2, mean, na.rm = TRUE))
}
library(Phase23Dose)
for(i in 1:length(input$rho)){
rho <- input$rho[i]
test.method <- input$test.method[i]
results <- parLapply(cl, (1:nclust), fun = getOC_ph23, seed = 202407, nsim = nsim_per_cluster, test.method = test.method,
hazardC = log(2)/medianOS_c, hazardT = log(2)/medianOS_c*hr_trt, orrC = 0.2, orrT = orr_trt, rho = rho, accrual_rate_stage1 = accrual_rate_stage1,
accrual_rate_stage2 = accrual_rate_stage2, n1_per_arm = n1_per_arm, n2_per_arm = n2_per_arm,
targetEventsIA_all = targetEventsIA_all, targetEventsFA_all = targetEventsFA_all,
wei_IA = wei_IA, wei_FA = wei_FA,
bound_z_IA = bound_z_IA, bound_z_FA = bound_z_FA, dropoutC = 1e-10,
ddropoutT = rep(1e-10, 3), alpha = alpha, update_bound_FA = update_bound_FA)
res.type1global[[i]] <- do.call(rbind, results)
#print(apply(res.type1global[[i]], 2, mean, na.rm = TRUE))
}
library(Phase23Dose)
tmp1 <- clusterCall(cl, function() {library(survival)
library(gsDesign)
library(simtrial)
library(dplyr)
library(knitr)
library(rpact)
library(nph)
library(mvtnorm);library(Phase23Dose);
library(parallel)
library(doParallel)})
stopCluster(cl)
nclust = 10
#nsim_per_cluster <- 1000
cl <- makeCluster(nclust, type = "PSOCK")
registerDoParallel(cl)
tmp1 <- clusterCall(cl, function() {library(survival)
library(gsDesign)
library(simtrial)
library(dplyr)
library(knitr)
library(rpact)
library(nph)
library(mvtnorm);library(Phase23Dose);
library(parallel)
library(doParallel)})
tmp2 <- clusterExport(cl, list("nclust"))
wei_FA
for(i in 1:length(input$rho)){
rho <- input$rho[i]
test.method <- input$test.method[i]
results <- parLapply(cl, (1:nclust), fun = getOC_ph23, seed = 202407, nsim = nsim_per_cluster, test.method = test.method,
hazardC = log(2)/medianOS_c, hazardT = log(2)/medianOS_c*hr_trt, orrC = 0.2, orrT = orr_trt, rho = rho, accrual_rate_stage1 = accrual_rate_stage1,
accrual_rate_stage2 = accrual_rate_stage2, n1_per_arm = n1_per_arm, n2_per_arm = n2_per_arm,
targetEventsIA_all = targetEventsIA_all, targetEventsFA_all = targetEventsFA_all,
wei_IA = wei_IA, wei_FA = wei_FA,
bound_z_IA = bound_z_IA, bound_z_FA = bound_z_FA, dropoutC = 1e-10,
ddropoutT = rep(1e-10, 3), alpha = alpha, update_bound_FA = update_bound_FA)
res.type1global[[i]] <- do.call(rbind, results)
#print(apply(res.type1global[[i]], 2, mean, na.rm = TRUE))
}
nsim_per_cluster <- 10 # Change it to 1000 or higher for final simulations
for(i in 1:length(input$rho)){
rho <- input$rho[i]
test.method <- input$test.method[i]
results <- parLapply(cl, (1:nclust), fun = getOC_ph23, seed = 202407, nsim = nsim_per_cluster, test.method = test.method,
hazardC = log(2)/medianOS_c, hazardT = log(2)/medianOS_c*hr_trt, orrC = 0.2, orrT = orr_trt, rho = rho, accrual_rate_stage1 = accrual_rate_stage1,
accrual_rate_stage2 = accrual_rate_stage2, n1_per_arm = n1_per_arm, n2_per_arm = n2_per_arm,
targetEventsIA_all = targetEventsIA_all, targetEventsFA_all = targetEventsFA_all,
wei_IA = wei_IA, wei_FA = wei_FA,
bound_z_IA = bound_z_IA, bound_z_FA = bound_z_FA, dropoutC = 1e-10,
ddropoutT = rep(1e-10, 3), alpha = alpha, update_bound_FA = update_bound_FA)
res.type1global[[i]] <- do.call(rbind, results)
#print(apply(res.type1global[[i]], 2, mean, na.rm = TRUE))
}
for(i in 1:length(input$rho)){
rho <- input$rho[i]
test.method <- input$test.method[i]
results <- parLapply(cl, (1:nclust), fun = getOC_ph23, seed = 202407, nsim = nsim_per_cluster, test.method = test.method,
hazardC = log(2)/medianOS_c, hazardT = log(2)/medianOS_c*hr_trt, orrC = 0.2, orrT = orr_trt, rho = rho, accrual_rate_stage1 = accrual_rate_stage1,
accrual_rate_stage2 = accrual_rate_stage2, n1_per_arm = n1_per_arm, n2_per_arm = n2_per_arm,
targetEventsIA_all = targetEventsIA_all, targetEventsFA_all = targetEventsFA_all,
wei_IA = wei_IA, wei_FA = wei_FA,
bound_z_IA = bound_z_IA, bound_z_FA = bound_z_FA, dropoutC = 1e-10,
dropoutT = rep(1e-10, 3), alpha = alpha, update_bound_FA = update_bound_FA)
res.type1global[[i]] <- do.call(rbind, results)
#print(apply(res.type1global[[i]], 2, mean, na.rm = TRUE))
}
## Combine the Results
type1global<-NULL
for(i in 1:length(input$rho)){
sim.results <- res.type1global[[i]]
type1global <- c(type1global, mean(sim.results[,4]))
}
type1global
library(Phase23Dose)
library(Phase23Dose)
library(Phase23Dose)
?gMCP::generatePvals
library(Phase23Dose)
?rlang::.data
?qnorm
library(Phase23Dose)
library(Phase23Dose)
